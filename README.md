# Синтаксис sig 

## Выработка ЭЦП

```
bee2cmd sig sign [-cert <cert>] [-pass <scheme>] <privkey> <file> <sig>
```

Brief:
* подписать `<file>` на `<privkey>` и сохранить подпись в `<sig>`.

Options:
* `-pass`: `<scheme>` описывает пароль активации `<privkey>`;
* `-cert`: `<cert>` содержит сертификат подписанта
  (сертификат открытого ключа, связанного с `<privkey>`).

Details:
* при совпадении `<sig>` и `<file>` подпись присоединяется к `<file>`
  (записывается в конец, покрывается случай --executable);
* при включении опции `-cert` сертификат `<cert>` переносится в подпись.

## Проверка ЭЦП

```
bee2cmd sig vfy [-pubkey <pubkey> | -anchor <anchor>] <file> <sig>
```

Brief:
* проверить подпись `<sig>` файла `<file>`.

Options:
* `-pubkey`: `<pubkey>` содержит открытый ключ, на котором проверяется подпись.
* `-anchor`: `<anchor>` содержит доверенный сертификат открытого ключа. Если
  подпись содержит сертификат `<cert>`, то он должен либо совпадать с `<anchor>`,
  либо признаваться действительным на `<anchor>`.

Details:
* при совпадении `<sig>` и `<file>` подпись прочитывается из конца `<file>`.

## Печать ЭЦП

```
bee2cmd sig print [-cert <cert>] <sig>
```

Brief:
* печатается подпись `<sig>`.

Options:
* `-cert`: если подпись содержит сертификат подписанта, то он сохраняется в
  файле `<cert>`.

# Формат подписи (ASN.1)

```
Signature ::= SEQUENCE
{
   certs SEQUENCE OF CVCertificate,
   sig OCTET STRING(SIZE(48|72|96))
}
```

Потенциально может быть указано несколько сертификатов (цепочка).

# Кодирование подписи

Подпись кодируется по правилам DER. DER-код (строка октетов) переворачивается.
За счет переворота DER-код однозначно декодируется даже будучи записанным в
конец файла произвольного размера.

# Реализация

```
typedef struct {
  octet sig[96];	                 /* подпись */
  size_t sig_len;	                 /* длина подписи в октетах */
  size_t certs_len[SIG_MAX_CERTS];   /* длины сертификатов */
} cmd_sig_t;
```

Сертификаты в `certs` записываются последовательно: сначала
`certs_len[0]` октетов первого сертификата, затем `certs_len[1]`
второго и так далее. Нулевое значение `certs_len[pos]` означает
отсутствие сертификата в позиции `pos`.

```
err_t cmdSigRead(cmd_sig_t* sig, octet certs[], size_t* der_len,  
const char* file);
```

Прочитать (обратный) DER-код подписи в конце `file`, разобрать его и, в случае
успеха, сохранить данные по адресу `sig`, а сертификаты --- по адресу `certs`.
Дополнительно возвратить длину кода по указателю `der_len` (если он ненулевой).
Указатель `certs` может быть нулевым, и тогда сертификаты не возвращаются.

```
err_t cmdSigWrite(size_t* der_len, const cmd_sig_t* sig, 
  const octet certs[], const char* file);
```

Кодировать подпись и сертификаты, описанные параметрами `sig` и `cert`.
Записать DER-код в конец `file`. Возвратить длину кода по указателю `der_len`
(если он ненулевой).
